class Node:
   def __init__(self, value):
       self.value = value
       self.next = None


class LinkedList:
   def __init__(self):
       self.head = None


   def add_first(self, value):
       new = Node(value)
       new.next = self.head
       self.head = new


   def add_last(self, value):
       new = Node(value)
       if self.head is None:
           self.head = new
           return
       curr = self.head
       while curr.next:
           curr = curr.next
       curr.next = new


   def insert(self, index, value):
       if index == 0:
           self.add_first(value)
           return
       new = Node(value)
       curr = self.head
       pos = 0
       while curr is not None and pos < index - 1:
           curr = curr.next
           pos += 1
       if curr is None:
           raise IndexError("Index out of range")
       new.next = curr.next
       curr.next = new


   def remove_first(self):
       if self.head is None:
           raise Exception("List is empty")
       self.head = self.head.next


   def remove_last(self):
       if self.head is None:
           raise Exception("List is empty")
       if self.head.next is None:
           self.head = None
           return
       curr = self.head
       while curr.next.next is not None:
           curr = curr.next
       curr.next = None


   def remove_at(self, index):
       if self.head is None:
           raise Exception("List is empty")
       if index == 0:
           self.remove_first()
           return
       curr = self.head
       pos = 0
       while curr.next is not None and pos < index - 1:
           curr = curr.next
           pos += 1
       if curr.next is None:
           raise IndexError("Index out of range")
       curr.next = curr.next.next



lijst printen naar terminal:
def print_list(self):
   curr = self.head
   while curr:
       print(curr.value, end=" -> ")
       curr = curr.next
   print("None")


def print_list(self):
   curr = self.head
   while curr:
       print(f"{curr.task_name}, {curr.duration}, {curr.priority}", end=" -> ")
       curr = curr.next
   print("None")


















class Node:
   def __init__(self, value):
       self.value = value
       self.next = None




class CircularLinkedList:
   def __init__(self):
       self.head = None


   def add_first(self, value):
       new = Node(value)


       if self.head is None:
           self.head = new
           new.next = new
           return


       # zoek laatste node
       last = self.head
       while last.next != self.head:
           last = last.next


       new.next = self.head
       self.head = new
       last.next = self.head


   def add_last(self, value):
       new = Node(value)


       if self.head is None:
           self.head = new
           new.next = new
           return


       last = self.head
       while last.next != self.head:
           last = last.next


       last.next = new
       new.next = self.head


   def print_list(self):
       if self.head is None:
           print("Empty")
           return


       curr = self.head
       while True:
           print(curr.value, end=" -> ")
           curr = curr.next
           if curr == self.head:
               break
       print("(back to head)")


Heap.py
PriorityQueue.py
Zorg dus dat beide bestanden in dezelfde map staan.


in je map: test_priority_queue.py
Gebruik Priority que: 
from PriorityQueue import PriorityQueue

pq = PriorityQueue()

pq.enqueue(30)
pq.enqueue(10)
pq.enqueue(20)
pq.enqueue(5)

print("Size:", pq.getSize())

print("Dequeue:", pq.dequeue())  # haalt elementen met hoogste prioriteit
print("Dequeue:", pq.dequeue())
print("Dequeue:", pq.dequeue())
print("Dequeue:", pq.dequeue()

Vb klasse
class Hond:
    def __init__(self, naam, leeftijd):
        self.naam = naam
        self.leeftijd = leeftijd

    def blaf(self):
        print("Woef!")


https://github.com/UGent-AlgoData-BusinessEngineering/Code_lectures_2526


LL 
zijn Node class:
in jouw code is element nergens gedefinieerd.
Dat betekent:
De Node-klasse die bij deze LinkedList hoort, heeft waarschijnlijk een attribuut element.
Bijvoorbeeld:
class Node:
    def __init__(self, element):
        self.element = element   # <-- DIT is het "element"
        self.next = None

Left as an exercise:
contains
remove
get
indexOf
lastIndexOf
set

class LinkedList:
    def __init__(self):
        self.__head = None
        self.__tail = None
        self.__size = 0

    # Return the head element in the list 
    def getFirst(self):
        if self.__size == 0:
            return None
        else:
            return self.__head.element
    
    # Return the last element in the list 
    def getLast(self):
        if self.__size == 0:
            return None
        else:
            return self.__tail.element

    # Add an element to the beginning of the list 
    def addFirst(self, e):
        newNode = Node(e) # Create a new node
        newNode.next = self.__head # link the new node with the head
        self.__head = newNode # head points to the new node
        self.__size += 1 # Increase list size

        if self.__tail == None: # the new node is the only node in list
            self.__tail = self.__head

    # Add an element to the end of the list 
    def addLast(self, e):
        newNode = Node(e) # Create a new node for e
    
        if self.__tail == None:
            self.__head = self.__tail = newNode # The only node in list
        else:
            self.__tail.next = newNode # Link the new with the last node
            self.__tail = self.__tail.next # tail now points to the last node
    
        self.__size += 1 # Increase size

    # Same as addLast 
    def add(self, e):
        self.addLast(e)

    # Insert a new element at the specified index in this list
    # The index of the head element is 0 
    def insert(self, index, e):
        if index == 0:
            self.addFirst(e) # Insert first
        elif index >= self.__size:
            self.addLast(e) # Insert last
        else: # Insert in the middle
            current = self.__head
            for i in range(1, index):
                current = current.next
            temp = current.next
            current.next = Node(e)
            (current.next).next = temp
            self.__size += 1

    # Remove the head node and
    #  return the object that is contained in the removed node. 
    def removeFirst(self):
        if self.__size == 0:
            return None # Nothing to delete
        else:
            temp = self.__head # Keep the first node temporarily
            self.__head = self.__head.next # Move head to point the next node
            self.__size -= 1 # Reduce size by 1
            if self.__head == None: 
                self.__tail = None # List becomes empty 
            return temp.element # Return the deleted element

    # Remove the last node and
    # return the object that is contained in the removed node
    def removeLast(self):
        if self.__size == 0:
            return None # Nothing to remove
        elif self.__size == 1: # Only one element in the list
            temp = self.__head
            self.__head = self.__tail = None  # list becomes empty
            self.__size = 0
            return temp.element
        else:
            current = self.__head
        
            for i in range(self.__size - 2):
                current = current.next
        
            temp = self.__tail
            self.__tail = current
            self.__tail.next = None
            self.__size -= 1
            return temp.element

    # Remove the element at the specified position in this list.
    #  Return the element that was removed from the list. 
    def removeAt(self, index):
        if index < 0 or index >= self.__size:
            return None # Out of range
        elif index == 0:
            return self.removeFirst() # Remove first 
        elif index == self.__size - 1:
            return self.removeLast() # Remove last
        else:
            previous = self.__head
    
            for i in range(1, index):
                previous = previous.next
        
            current = previous.next
            previous.next = current.next
            self.__size -= 1
            return current.element

    # Return true if the list is empty
    def isEmpty(self):
        return self.__size == 0
    
    # Return the size of the list
    def getSize(self):
        return self.__size

    def __str__(self):
        result = "["

        current = self.__head
        for i in range(self.__size):
            result += str(current.element)
            current = current.next
            if current != None:
                result += ", " # Separate two elements with a comma
            else:
                result += "]" # Insert the closing ] in the string

        return result

    # Clear the list */
    def clear(self):
        self.__head = self.__tail = None
        self.__size = 0

    # Return true if this list contains the element e 
    def contains(self, e):
        current = self.__head
        while current is not None:
            if current.element == e:
                return True
            current = current.next
        return False

    # Remove the element and return true if the element is in the list 
    def remove(self, e):
        if self.__size == 0:
            return False

        # Speciaal geval: element zit in de head
        if self.__head.element == e:
            self.removeFirst()
            return True

        previous = self.__head
        current = self.__head.next

        while current is not None:
            if current.element == e:
                previous.next = current.next
                if current == self.__tail:  # als we de tail verwijderen
                    self.__tail = previous
                self.__size -= 1
                return True
            previous = current
            current = current.next

        return False  # niet gevonden

    # Return the element from this list at the specified index 
    def get(self, index):
        if index < 0 or index >= self.__size:
            return None

        current = self.__head
        for i in range(index):
            current = current.next
        return current.element

    # Return the index of the head matching element in this list.
    # Return -1 if no match.
    def indexOf(self, e):
        current = self.__head
        index = 0
        while current is not None:
            if current.element == e:
                return index
            current = current.next
            index += 1
        return -1

    # Return the index of the last matching element in this list
    #  Return -1 if no match. 
    def lastIndexOf(self, e):
        current = self.__head
        index = 0
        lastIndex = -1
        while current is not None:
            if current.element == e:
                lastIndex = index
            current = current.next
            index += 1
        return lastIndex

    # Replace the element at the specified position in this list
    #  with the specified element. */
    def set(self, index, e):
        if index < 0 or index >= self.__size:
            return None

        current = self.__head
        for i in range(index):
            current = current.next

        old = current.element
        current.element = e
        return old
    
    # Return elements via indexer
    def __getitem__(self, index):
        return self.get(index)

    # Return an iterator for a linked list
    def __iter__(self):
        return LinkedListIterator(self.__head)
    
# The Node class
class Node:
    def __init__(self, e):
        self.element = e
        self.next = None

class LinkedListIterator: 
    def __init__(self, head):
        self.current = head
        
    def __next__(self):
        if self.current == None:
            raise StopIteration
        else:
            element = self.current.element
            self.current = self.current.next
            return element




def removeFirst(self):
    if self.__size == 0:
        return None # Nothing to delete
    else:
        temp = self.__head # Keep the first node temporarily
        self.__head = self.__head.next # Move head to point the next node
        self.__size -= 1 # Reduce size by 1
        if self.__head == None: 
            self.__tail = None # List becomes empty 
        return temp.element # Return the deleted element 

def remove_task(self, task_name):
    # als lijst leeg is â†’ niets verwijderen
    if self.head is None:
        return None

    # 1. Speciale case: head verwijderen
    if self.head.task_name == task_name:
        removed = self.head
        self.head = self.head.next
        return removed.task_name  # of removed zelf teruggeven

    # 2. Normale case: door de lijst lopen
    prev = self.head
    curr = self.head.next

    while curr is not None:
        if curr.task_name == task_name:
            # verwijder curr door prev.next te veranderen
            prev.next = curr.next
            return curr.task_name
        prev = curr
        curr = curr.next

    # 3. Niets gevonden
    return None
